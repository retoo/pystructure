// -*- java -*-
//good reading for error handling: https://javacc.dev.java.net/doc/errorrecovery.html
options
{
    // only non-defaults are given here.
    NODE_SCOPE_HOOK       = true;   // call jjtree*NodeScope()
    NODE_FACTORY          = true;
    NODE_USES_PARSER      = true;
    STATIC                = false;  // multiple parsers
    COMMON_TOKEN_ACTION   = true;   // CommonTokenAction(Token)
    DEBUG_PARSER          = false;  // must be used to enable tracing 
    DEBUG_TOKEN_MANAGER   = false;  // used to debug the tokens we have generating 

    USER_CHAR_STREAM      = true;
    UNICODE_INPUT         = true;
    ERROR_REPORTING       = true;  // this is NOT used to shut down errors regarding javacc org.python.pydev.parser.jython.PythonGrammar$LookaheadSuccess
                                      // because the generated information is not complete enough if we do it.
}


PARSER_BEGIN(PythonGrammar24)
package org.python.pydev.parser.grammar24;
import org.python.pydev.parser.jython.ast.modType;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import org.python.pydev.parser.jython.ast.Call;
import org.python.pydev.parser.jython.ast.Str;
import org.python.pydev.parser.jython.ast.Import;
import org.python.pydev.parser.jython.ast.Num;
import org.python.pydev.parser.jython.ast.Yield;
import org.python.pydev.parser.jython.ast.Tuple;
import org.python.pydev.parser.jython.ast.ImportFrom;
import org.python.pydev.core.IPythonNature;
import org.python.pydev.parser.jython.IParserHost;
import org.python.pydev.parser.jython.SimpleNode;
import org.python.pydev.parser.jython.Node;
import org.python.pydev.parser.jython.Token;
import org.python.pydev.parser.jython.ParseException;
import org.python.pydev.parser.jython.SpecialStr;
import org.python.pydev.parser.jython.TokenMgrError;
import org.python.pydev.parser.jython.CharStream;
import org.python.pydev.parser.IGrammar;

public class PythonGrammar24 implements IGrammar
{

    public IParserHost hostLiteralMkr;
    private SimpleNode prev;
    private static boolean DEBUG = false;
    private final static boolean DEFAULT_SEARCH_ON_LAST = false;

    void jjtreeOpenNodeScope(Node n) {
        if(DEBUG){
            System.out.println("opening scope:"+n);
        }
        Token t = getToken(1);
        jjtree.pushNodePos(t.beginLine, t.beginColumn);
    }

    void addToPeek(Object t, boolean after) {
        addToPeek(t, after, null);
    }

    void addToPeekCallFunc(Object t, boolean after) {
        Call n = (Call) jjtree.peekNode();
        n.func.addSpecial(t, after);
    }

    void addToPeek(Object t, boolean after, Class class_) {
        SimpleNode peeked = (SimpleNode) jjtree.peekNode();
        addToPeek(peeked, t, after, class_);
    }
    
    void addToPeek(SimpleNode peeked, Object t, boolean after, Class class_) {
        if (class_ != null) {
            // just check if it is the class we were expecting.
            if (peeked.getClass().equals(class_) == false) {
                throw new RuntimeException("Error, expecting another class.");
            }
        }
        t = convertStringToSpecialStr(t);
        peeked.addSpecial(t, after);
    }

    void jjtreeCloseNodeScope(Node n) {
        if (DEBUG) {
            System.out.println("closing scope:" + n);
        }
        SimpleNode peeked = jjtree.setNodePos();
        List specialTokens = token_source.specialTokens;
        boolean after = true;
        if (n instanceof SimpleNode) {
            if (specialTokens.size() > 0) {
                if (prev == null) {
                    // it was not previously set, let's get the current and add it before that token
                    after = false;
                    prev = peeked;
                }
                if (DEBUG) {
                    System.out.println("closing scope " + peeked.getClass());
                }

                for (Iterator iter = specialTokens.iterator(); iter.hasNext();) {
                    Object next = iter.next();
                    int strategy = STRATEGY_ADD_AFTER_PREV; // default strategy
                    if (next instanceof Object[]) {
                        strategy = (Integer) ((Object[]) next)[1];
                        next = ((Object[]) next)[0];
                    }

                    if (strategy == STRATEGY_BEFORE_NEXT) { // try to set 'before the next' and not after prev token
                        addToPeek(peeked, next, false, null);
                    } else {
                        // may still add before the next, if there was no prev (we can check that by the 'after' variable)
                        // in this case, we'll do some checks to see if it is really correct (checking for the line and column)

                        if (next instanceof Token) {
                            findTokenToAdd((Token) next).addSpecial(next, after);
                        } else {
                            prev.addSpecial(next, after);
                        }
                    }
                }
                specialTokens.clear();
            }
            prev = (SimpleNode) peeked;
        }
    }


    /**
     * Default: add after the previous found token
     */
    public static final int STRATEGY_ADD_AFTER_PREV = 0;

    /**
     * Add before the 'next token' strategy
     */
    public static final int STRATEGY_BEFORE_NEXT = 1;
    
    private SimpleNode findTokenToAdd(Token next) {
        SimpleNode curr = (SimpleNode) jjtree.peekNode();
        if(curr != prev){
            //let's see which one is better suited
            if(prev.beginLine == next.beginLine){
                return prev;
            }
            if(curr.beginLine == next.beginLine){
                return curr;
            }
            //if it was found later than both, let's get the current
            if(next.beginLine > prev.beginLine && next.beginLine > curr.beginLine){
                return curr;
            }

        }
        return prev;
        
    }

    private void addSpecialToken(Object o, int strategy) {
        o = convertStringToSpecialStr(o);    
        token_source.specialTokens.add(new Object[]{o, strategy});
    }
    
	private Object convertStringToSpecialStr(Object o) {
		if (o instanceof String) {
			try {
				o = createSpecialStr((String) o);
			} catch (ParseException e) {
			}
		}
		return o;
	}    
    
    private void addSpecialToken(Object o) {
        //the default is adding after the previous token
        token_source.specialTokens.add(new Object[]{o, STRATEGY_ADD_AFTER_PREV});
    }


    private boolean findTokenAndAdd(String token) throws ParseException {
        return findTokenAndAdd(token, token, DEFAULT_SEARCH_ON_LAST);
    }

    private Object createSpecialStr(String token) throws ParseException {
        return createSpecialStr(token, token);
    }
    private Object createSpecialStr(String token, boolean searchOnLast) throws ParseException {
        return createSpecialStr(token, token, searchOnLast);
    }

    private Object createSpecialStr(String token, String put) throws ParseException {
        return createSpecialStr(token, put, DEFAULT_SEARCH_ON_LAST);
    }
    private Object createSpecialStr(String token, String put, boolean searchOnLast) throws ParseException {
        Token t;
        if(searchOnLast){
                t = jj_lastpos;
        }else{
                t = this.token;
        }
        while(t != null && t.image != null && t.image.equals(token) == false){
                t = t.next;
        }
        if(t != null){
                return new SpecialStr(put,t.beginLine, t.beginColumn);
        }
        //return put;
        if(this.token != null){
            throw new ParseException("Expected:"+token, this.token);
        }else if(jj_lastpos != null){
            throw new ParseException("Expected:"+token, jj_lastpos);
        }else{
            throw new ParseException("Expected:"+token);
        }
    }

    /**
     * This is so that we add the String with the beginLine and beginColumn
     * @throws ParseException 
     */
    private boolean findTokenAndAdd(String token, String put, boolean searchOnLast) throws ParseException {
        Object s = createSpecialStr(token, put, searchOnLast);
        token_source.specialTokens.add(new Object[]{s, STRATEGY_ADD_AFTER_PREV});
        return s instanceof SpecialStr;
    }



    Object[] makeInt(String s, int radix, String token) {
        if (s.endsWith("L") || s.endsWith("l")) {
            s = s.substring(0, s.length()-1);
            return new Object[]{hostLiteralMkr.newLong(new java.math.BigInteger(s, radix)), Num.Long, token};
        }
        int ndigits = s.length();
        int i=0;
        while (i < ndigits && s.charAt(i) == '0')
            i++;
        if ((ndigits - i) > 11) {
            return new Object[]{hostLiteralMkr.newLong(new java.math.BigInteger(s, radix)), Num.Long, token};
        }

        long l = Long.valueOf(s, radix).longValue();
        if (l > 0xffffffffl || (radix == 10 && l > Integer.MAX_VALUE)) {
            return new Object[]{hostLiteralMkr.newLong(new java.math.BigInteger(s, radix)), Num.Long, token};
        }
        return new Object[]{hostLiteralMkr.newInteger((int) l), Num.Int, token};
    }

    Object[] makeFloat(String s) {
        return new Object[]{hostLiteralMkr.newFloat(Double.valueOf(s).doubleValue()), Num.Float, s};
    }

    Object[] makeLong(String s) {
        return new Object[]{hostLiteralMkr.newLong(s), Num.Long, s};
    }

    Object[] makeComplex(String s) {
        String compNumber = s.substring(0, s.length() - 1);
        return new Object[]{hostLiteralMkr.newImaginary(Double.valueOf(compNumber).doubleValue()), Num.Comp, s};
    }

    /**
     * Return a Tuple where:
     * 0 = the string
     * 1 = boolean indicating unicode
     * 2 = boolean indicating raw
     * 3 = style
     */
    Object[] makeString(String s, int quotes) {
        //System.out.println("enter: "+s);
        char quoteChar = s.charAt(0);
        int start=0;
        boolean ustring = false;
        if (quoteChar == 'u' || quoteChar == 'U') {
            ustring = true;
            start++;
        }
        quoteChar = s.charAt(start);
        if (quoteChar == 'r' || quoteChar == 'R') {
            //raw string (does not decode slashes)
            String str = s.substring(quotes+start+1, s.length()-quotes);
            //System.out.println("out: "+str);
            return new Object[]{str,ustring, true, getType(s.charAt(start+1), quotes)};

        } else {
            int n = s.length()-quotes;
            int i=quotes+start;

            String str = hostLiteralMkr.decode_UnicodeEscape(s, i, n, "strict", ustring);
            //System.out.println("out: "+str);
            return new Object[]{str, ustring, false, getType(s.charAt(start), quotes)};
        }
    }
    
    private int getType(char c, int quotes){
        if(quotes == 1){
            if (c == '\''){
                return Str.SingleSingle;
            }
            if(c == '"'){
                return Str.SingleDouble;
            }
        }
        if (c == '\''){
            return Str.TripleSingle;
        }
        if(c == '"'){
            return Str.TripleDouble;
        }
        throw new RuntimeException("Unable to determine type. Char: "+c+" quotes:"+quotes );
    }

    // ! maximal currently used LOOKAHEAD is 3
    private static final int MAX_LOOKAHEAD = 3;

    public boolean partial_valid_sentence(Throwable t) {
        if (t instanceof TokenMgrError) {
           // check whether EOF condition inside multi-line string,
           // or just after newline continuation inside a string (*NLC states)
           TokenMgrError e = (TokenMgrError)t;
           switch(e.lexState) {
           case IN_STRING1NLC:
           case IN_STRING2NLC:
           case IN_STRING13:
           case IN_STRING23:
           case IN_USTRING1NLC:
           case IN_USTRING2NLC:
           case IN_USTRING13:
           case IN_USTRING23:
               return e.EOFSeen;
           default:
               return false;
           }
        }
        if (!(t instanceof ParseException))
            return false;
        try {
            ParseException e = (ParseException)t;
            int tok = getNextToken().kind;
            if (tok == EOF) return true; // all tokens eaten

            // or check whether remaing tokens partially fullfill lookahead
            // expectations

            int[][] expected = e.expectedTokenSequences;

            if (expected == null) return false;

            int[] ahead = new int[MAX_LOOKAHEAD-1];

            int i = 0;
            for(;;) {
                ahead[i] = tok;
                i++;
                tok = getNextToken().kind;
                if (tok == EOF) break;
                if (i >= MAX_LOOKAHEAD-1) return false;
            }

            int nahead = i;

        next_expected:
            for(int j = 0; j<expected.length; j++) {
                int[] cand = expected[j];

                if (cand.length <= nahead ) continue next_expected;

                for(int k = 0; k < nahead; k++)
                    if (ahead[k] != cand[k])
                        continue next_expected;
                return true;
            }

            return false;
        } catch (TokenMgrError e1) {
            return false;
        }
    }

   // constructors taking a IParserHost impl

   public PythonGrammar24(CharStream stream,IParserHost host) {
       this(stream);
       hostLiteralMkr = host;
   }

   public PythonGrammar24(PythonGrammar24TokenManager tm,
                        IParserHost host)
   {
        this(tm);
        hostLiteralMkr = host;
   }

}


PARSER_END(PythonGrammar24)

TOKEN_MGR_DECLS:
{
    int indentation[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int level = 0;
    int dedents = 0;
    int parens = 0;
    int indent;

    boolean expect_indent = false;

    boolean compound = false;

    public boolean single_input = false;

    public List specialTokens = new ArrayList();

    // parsing of partial sentence (interactive) mode
    public boolean partial = false;
    // control whether empty new lines on EOF force sentence closing NEWLINE even if indent
    // is expected,i.e. classic behavior at jython prompt (different from codeop behavior)
    public boolean stdprompt = false;

    static Token addDedent(Token previous) {
        Token t = new Token();
        t.kind = DEDENT;
        t.beginLine = previous.beginLine;
        t.endLine = previous.endLine;
        t.beginColumn = previous.beginColumn;
        t.endColumn = previous.endColumn;
        t.image = "<DEDENT>";
        t.specialToken = null;
        t.next = null;
        previous.next = t;
        return t;
    }
    
    void CommonTokenAction(Token t) {
        /*
           if not partial: EOF is expanded to token sequences comprising
               if single_input: [NEWLINE] necessary DEDENT NEWLINE (afterward EOF)
               otherwise      : [NEWLINE] necessary DEDENT EOF
           if partial: EOF expansion happens only if EOF preceded by empty line (etc),
           i.e. lexer is in MAYBE_FORCE_NEWLINE_IF_EOF state
           System.out.println("Token:'"+t+"'");
           System.out.println("Special:'"+t.specialToken+"'");
        */

        int i = specialTokens.size();
        while(t.specialToken != null){
                this.specialTokens.add(i, t.specialToken);
                t = t.specialToken;
        }
        
        if (t.kind == EOF) {
            // System.out.println("EOF: "+single_input+", "+curLexState+", "+level);
            if (!partial || curLexState == MAYBE_FORCE_NEWLINE_IF_EOF) {
                if (curLexState == DEFAULT) {
                    t.kind = NEWLINE;
                }
                else {
                    t.kind = DEDENT;
                    if (level >= 0) level -= 1;
                }
                while (level >= 0) {
                    level--;
                    t = addDedent(t);
                }
                if (!single_input) {
                    t.kind = EOF;
                    t.image = "<EOF>";
                } else {
                    t.kind = NEWLINE;
                    t.image = "<FORCENL>";
                    single_input = false;
                }
            }
        } 
    }

    void indenting(int ind) {
        indent = ind;
        if (indent == indentation[level])
            SwitchTo(INDENTATION_UNCHANGED);
        else
            SwitchTo(INDENTING);
    }
}


SKIP :
{
    <SPACE: " ">
|   "\t"
|   "\014"
|   <CONTINUATION: ("\\") ("\r\n"|"\n"|"\r")>
|   <NEWLINE1: ("\r\n"|"\n"|"\r")>
        {
            if (parens == 0) {
                indent = 0;
                input_stream.backup(1);
                if (level == 0)
                    SwitchTo(FORCE_NEWLINE1);
                else
                    SwitchTo(FORCE_NEWLINE2);
            }
        }
}


<FORCE_NEWLINE1> TOKEN :
{ <NEWLINE: ("\n" | "\r")> : INDENTATION_UNCHANGED }


<FORCE_NEWLINE2> TOKEN :
{ <NEWLINE2: ("\n" | "\r")> { matchedToken.kind = NEWLINE; }: INDENTING }


// causes expected warning
<MAYBE_FORCE_NEWLINE_IF_EOF> SKIP :
{
    <""> { indenting(0); }
}

<INDENTING, INDENTATION_UNCHANGED> SKIP :
{
    "\t"
        { indenting((indent/8+1)*8); }
|   " "
        { indenting(indent+1); }
|   "\014"
        { indenting(0); }
|   <CRLF1: ("\r\n" | "\n" | "\r")>
        {
            //System.out.println("empty line");
            // if partial single_input (interactive) mode,
            // empty line (indent==0), and no parens open
            // or indentetion expected (if stdprompt == true, ovveride last cond)
            // consider forcing sentence closing NEWLINE if EOF
            if (partial && single_input && indent == 0 &&
                           parens == 0  && (stdprompt || !expect_indent)) {
                //System.out.println("force newline");
                //backup a character!
                // - input_stream.backup(1); -
                SwitchTo(MAYBE_FORCE_NEWLINE_IF_EOF);
            }
            else
                indenting(0);
        }
}


<INDENTATION_UNCHANGED> SKIP :
{
    <""> : DEFAULT
}


<INDENTING> TOKEN :
{
    <DEDENT: "">
        {
            if (indent > indentation[level]) {
                level++;
                indentation[level] = indent;
                matchedToken.kind=INDENT;
                matchedToken.image = "<INDENT>";
            }
            else if (level > 0) {
                Token t = matchedToken;
                level -= 1;
                while (level > 0 && indent < indentation[level]) {
                    level--;
                    t = addDedent(t);
                }
                if (indent != indentation[level]) {
                    throw new TokenMgrError("inconsistent dedent",
                                            t.endLine, t.endColumn);
                }
                t.next = null;
            }
        } : DEFAULT
}


<UNREACHABLE> TOKEN :
{
    < INDENT:"<INDENT>">
//|     < DEDENT:"<DEDENT>">
}


<DEFAULT> SPECIAL_TOKEN: /* COMMENTS 1*/
{
    <TRAILING_COMMENT: "#" (~["\n","\r"])* >{
//    System.out.println("TRAILING_COMMENT "+image);
//    matchedToken.image = image.toString();
    }
}

<INDENTING, INDENTATION_UNCHANGED> SPECIAL_TOKEN: /* COMMENTS 2*/
{
    <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\r\n" | "\n" | "\r")> {
//    System.out.println("SINGLE_LINE_COMMENT "+image);
//    matchedToken.image = image.toString();
        indenting(0);
    }
}

TOKEN : /* SEPARATORS */
{
    < LPAREN: "(" > {parens++;}
|   < RPAREN: ")" > {parens--;}
|   < LBRACE: "{" > {parens++;}
|   < RBRACE: "}" > {parens--;}
|   < LBRACKET: "[" > {parens++;}
|   < RBRACKET: "]" > {parens--;}
|   < SEMICOLON: ";" >
|   < COMMA: "," >
|   < DOT: "." >
|   < COLON: ":" >
}


TOKEN : /* OPERATORS */
{
    < PLUS: "+" >
|   < MINUS: "-" >
|   < MULTIPLY: "*" >
|   < DIVIDE: "/" >
|   < FLOORDIVIDE: "//" >
|   < POWER: "**" >
|   < LSHIFT: "<<" >
|   < RSHIFT: ">>" >
|   < MODULO: "%" >
|   < NOT: "~" >
|   < XOR: "^" >
|   < OR: "|" >
|   < AND: "&" >
|   < EQUAL: "=" >
|   < GREATER: ">" >
|   < LESS: "<" >
|   < EQEQUAL: "==" >
|   < EQLESS: "<=" >
|   < EQGREATER: ">=" >
|   < LESSGREATER: "<>" >
|   < NOTEQUAL: "!=" >
|   < PLUSEQ: "+=" >
|   < MINUSEQ: "-=" >
|   < MULTIPLYEQ: "*=" >
|   < DIVIDEEQ: "/=" >
|   < FLOORDIVIDEEQ: "//=" >
|   < MODULOEQ: "%=" >
|   < ANDEQ: "&=" >
|   < OREQ: "|=" >
|   < XOREQ: "^=" >
|   < LSHIFTEQ: "<<=" >
|   < RSHIFTEQ: ">>=" >
|   < POWEREQ: "**=" >
}

TOKEN : /* KEYWORDS */
{
    < OR_BOOL: "or" >
|   < AND_BOOL: "and" >
|   < NOT_BOOL: "not" >
|   < IS: "is" >
|   < IN: "in" >
|   < LAMBDA: "lambda" >
|   < IF: "if" >
|   < ELSE: "else" >
|   < ELIF: "elif" >
|   < WHILE: "while" >
|   < FOR: "for" >
|   < TRY: "try" >
|   < EXCEPT: "except" >
|   < DEF: "def" >
|   < CLASS: "class" >
|   < FINALLY: "finally" >
|   < PRINT: "print" >
|   < PASS: "pass" >
|   < BREAK: "break" >
|   < CONTINUE: "continue" >
|   < RETURN: "return" >
|   < YIELD: "yield" >
|   < IMPORT: "import" >
|   < FROM: "from" >
|   < DEL: "del" >
|   < RAISE: "raise" >
|   < GLOBAL: "global" >
|   < EXEC: "exec" >
|   < ASSERT: "assert" >
|   < AS: "as" >
|   < AT: "@" >
}


TOKEN : /* Python identifiers */
{
    < NAME: <LETTER> ( <LETTER> | <DIGIT>)* >
|   < #LETTER: ["_","a"-"z","A"-"Z"] >
}


TOKEN : /* Numeric literals */
{
    < DECNUMBER:
        ["1"-"9"] (["0"-"9"])* (["l", "L"])?
      | "0"
      >
|   < HEXNUMBER: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (["l","L"])? >
|   < OCTNUMBER: "0" (["0"-"7"])* (["l","L"])? >
|
    < FLOAT:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
      >
|   < COMPLEX: (<DECNUMBER> | <FLOAT> | "0" <DECNUMBER> ) ["j", "J"]>
|   < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|   < #DIGIT: ["0" - "9"] >
}


MORE : /* Strings */
{
    < (["u", "U"]) (["r", "R"])? "'" > :  IN_USTRING11
|   < (["u", "U"]) (["r", "R"])? "\"" > :  IN_USTRING21
|   < (["u", "U"]) (["r", "R"])? "'''" > :  IN_USTRING13
|   < (["u", "U"]) (["r", "R"])? "\"\"\"" > :  IN_USTRING23
|   < (["r", "R"])? "'" > :  IN_STRING11
|   < (["r", "R"])? "\"" > :  IN_STRING21
|   < (["r", "R"])? "'''" > :  IN_STRING13
|   < (["r", "R"])? "\"\"\"" > :  IN_STRING23
}

<IN_STRING11> TOKEN : { <SINGLE_STRING: "'"> {
    matchedToken.image = image.toString(); } : DEFAULT}
<IN_STRING21> TOKEN : { <SINGLE_STRING2: "\""> {
    matchedToken.image = image.toString(); } : DEFAULT}
<IN_STRING13> TOKEN : { <TRIPLE_STRING: "'''"> {
    matchedToken.image = image.toString(); } : DEFAULT}
<IN_STRING23> TOKEN : { <TRIPLE_STRING2: "\"\"\""> {
    matchedToken.image = image.toString(); } : DEFAULT}

<IN_USTRING11> TOKEN : { <SINGLE_USTRING: "'"> {
    matchedToken.image = image.toString(); } : DEFAULT}
<IN_USTRING21> TOKEN : { <SINGLE_USTRING2: "\""> {
    matchedToken.image = image.toString(); } : DEFAULT}
<IN_USTRING13> TOKEN : { <TRIPLE_USTRING: "'''"> {
    matchedToken.image = image.toString(); } : DEFAULT}
<IN_USTRING23> TOKEN : { <TRIPLE_USTRING2: "\"\"\""> {
    matchedToken.image = image.toString(); } : DEFAULT}

<IN_STRING11> MORE:
{
    <"\\\r\n">           { image.setLength(image.length()-3); } : IN_STRING1NLC
|   <("\\" ("\n"|"\r"))> { image.setLength(image.length()-2); } : IN_STRING1NLC
}

<IN_STRING21> MORE:
{
    <"\\\r\n">           { image.setLength(image.length()-3); } : IN_STRING2NLC
|   <("\\" ("\n"|"\r"))> { image.setLength(image.length()-2); } : IN_STRING2NLC
}

<IN_USTRING11> MORE:
{
    <"\\\r\n">           { image.setLength(image.length()-3); } : IN_USTRING1NLC
|   <("\\" ("\n"|"\r"))> { image.setLength(image.length()-2); } : IN_USTRING1NLC
}

<IN_USTRING21> MORE:
{
    <"\\\r\n">           { image.setLength(image.length()-3); } : IN_USTRING2NLC
|   <("\\" ("\n"|"\r"))> { image.setLength(image.length()-2); } : IN_USTRING2NLC
}

<IN_STRING1NLC> MORE:
{
 <""> : IN_STRING11
}

<IN_STRING2NLC> MORE:
{
 <""> : IN_STRING21
}

<IN_USTRING1NLC> MORE:
{
 <""> : IN_USTRING11
}

<IN_USTRING2NLC> MORE:
{
 <""> : IN_USTRING21
}

<IN_STRING11, IN_USTRING11> MORE: { <("\\" ("\\"|"'")) | ~["\n","\r"]> }
<IN_STRING21, IN_USTRING21> MORE: { <("\\" ("\\"|"\"")) | ~["\n","\r"]> }

/* This is a test to see if we can make the loading of strings more efficient (and maybe replace the MORE that is declared below.
I stopped this because I've seen that making the CharStream was apparently the number 1 thing to do, but it might be worth
comming back to this approach later).
<IN_STRING23> MORE:
{
    <~[]> 
    {
         try {
                 while(true){
                         char c = input_stream.readChar();
                         image.append(c);
                         int len = image.length();
                         if(len > 3 && image.charAt(len-3) == '"' && image.charAt(len-2) == '"'  && image.charAt(len-1) == '"' ){
                                 input_stream.backup(3);
                                 image.delete(image.length()-3, image.length());
                                 break;
                         }
                 }
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
    }
}
*/

<IN_STRING13, IN_STRING23, IN_USTRING13, IN_USTRING23> MORE:
{
    <"\r\n"> {
        int l = image.length();
        image.setLength(l-1);
        image.setCharAt(l-2, '\n');
    }
|   <"\n">
|   <"\r"> { image.setCharAt(image.length()-1, '\n'); }
|   <~["\n","\r"]>
|   <"\\" ~["\n","\r"]>
}

//single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
// apparently CPython coalesces newlines, we don't
modType single_input(): {
    token_source.single_input=true;
}
{
    (LOOKAHEAD(2) <NEWLINE>)* [(simple_stmt() | compound_stmt() <NEWLINE>)] (<NEWLINE>)* <EOF>
    { return (modType) jjtree.popNode(); }
}

//file_input: (NEWLINE | stmt)* ENDMARKER
modType file_input(): {token_source.single_input=false;}
{
    (<NEWLINE> | stmt())* <EOF>
    { return (modType) jjtree.popNode(); }
}

//eval_input: NEWLINE* testlist NEWLINE* ENDMARKER
modType eval_input(): {token_source.single_input=false;}
{
    (<NEWLINE>)* SmartTestList() (<NEWLINE>)* <EOF>
    { return (modType) jjtree.popNode(); }
}

//funcdef: 'def' NAME parameters ':' suite
void funcdef(): {}
{ 
    decorators()
    <DEF> AnyName() parameters() <COLON> {this.addSpecialToken(":");} suite() 
}

//@ call, name, attr ... <nl>
void decorators(): {}
{
    (begin_decorator() (<LPAREN>  {this.addSpecialToken("(", STRATEGY_BEFORE_NEXT);} insidetuporcall() <RPAREN>  {this.findTokenAndAdd(")");} )* <NEWLINE> )* 
}
void begin_decorator(): {}
{ <AT> dotted_name()
}

//parameters: '(' [varargslist] ')'
void parameters() #void: {}
{ <LPAREN>{this.findTokenAndAdd("(");}
  [varargslist()] 
  <RPAREN>{this.findTokenAndAdd(")");} 
  }

//varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' ('**'|'*' '*') NAME] | ('**'|'*' '*') NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']
void varargslist() #void: {}
{
    defaultarg() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> defaultarg())*
        [LOOKAHEAD(3) {this.addSpecialToken(",");} <COMMA> ExtraArgList()]
        [LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> ExtraKeywordList()]
        [{this.addSpecialToken(",");} <COMMA>]
    |   ( LOOKAHEAD(2) ExtraArgList() [{this.addSpecialToken(",");} <COMMA> ExtraKeywordList()]
    | ExtraKeywordList()
    )
}

void ExtraArgList(): {}
{ <MULTIPLY> {this.addSpecialToken("*", STRATEGY_BEFORE_NEXT);} Name() }

void ExtraKeywordList(): {}
{ (<POWER>{this.addSpecialToken("**", STRATEGY_BEFORE_NEXT);}|<MULTIPLY> {this.addSpecialToken("*", STRATEGY_BEFORE_NEXT);}{this.addSpecialToken("*", STRATEGY_BEFORE_NEXT);} <MULTIPLY>) Name() }

void defaultarg(): {}
{ fpdef() [<EQUAL> test()] }

//fpdef: NAME | '(' fplist ')'
void fpdef() #void: {}
{ Name() | <LPAREN>  {this.addSpecialToken("(",STRATEGY_BEFORE_NEXT);}   fplist() <RPAREN> {this.findTokenAndAdd(")");}  }

//fplist: fpdef (',' fpdef)* [',']
void fplist() #tuple: {}
{ fpdef() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> fpdef())* [{this.addSpecialToken(",");} <COMMA>] }


//stmt: simple_stmt | compound_stmt
void stmt() #void: {}
{ simple_stmt() | compound_stmt() }

//simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
void simple_stmt() #void: {}
{ small_stmt() (LOOKAHEAD(2) <SEMICOLON> small_stmt())* [<SEMICOLON>] <NEWLINE>
}

//small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | exec_stmt | assert_stmt
void small_stmt() #void: {SimpleNode simpleNode;}
{
    expr_stmt()
|   print_stmt()
|   del_stmt()
|   pass_stmt() {addToPeek("pass", false); }
|   flow_stmt()
|   import_stmt()
|   global_stmt()
|   exec_stmt()
|   assert_stmt() {addToPeek("assert ", false); }
}

//expr_stmt: testlist (augassign testlist | ('=' testlist)*)
void expr_stmt() #void: {}
{
    SmartTestList() (
    <PLUSEQ> SmartTestList() #aug_plus(2)
|   <MINUSEQ> SmartTestList() #aug_minus(2)
|   <MULTIPLYEQ> SmartTestList() #aug_multiply(2)
|   <DIVIDEEQ> SmartTestList() #aug_divide(2)
|   <FLOORDIVIDEEQ> SmartTestList() #aug_floordivide(2)
|   <MODULOEQ> SmartTestList() #aug_modulo(2)
|   <ANDEQ> SmartTestList() #aug_and(2)
|   <OREQ> SmartTestList() #aug_or(2)
|   <XOREQ> SmartTestList() #aug_xor(2)
|   <LSHIFTEQ> SmartTestList() #aug_lshift(2)
|   <RSHIFTEQ> SmartTestList() #aug_rshift(2)
|   <POWEREQ> SmartTestList() #aug_power(2)
|   (<EQUAL> SmartTestList())* #expr_stmt(jjtree.nodeArity()+1)
    )
}

//print_stmt: 'print' (test ',')* [test] | 'print' '>>' test (, test)+ [,]
void print_stmt() #void: {}
{
    LOOKAHEAD(2) <PRINT> <RSHIFT>  
    (test() [ (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> test())+ [Comma()] ] )#printext_stmt
    
|   LOOKAHEAD(2) <PRINT> 
    (test() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> test())* [Comma()])#print_stmt

|   <PRINT>  #print_stmt

}


//del_stmt: 'del' exprlist
void del_stmt(): {}
{ begin_del_stmt() exprlist() }

void begin_del_stmt(): {}
{ <DEL> {this.addToPeek("del ",false);}
}

//pass_stmt: 'pass'
void pass_stmt(): {}
{ <PASS> }

//flow_stmt: break_stmt | continue_stmt | return_stmt | yield_stmt | raise_stmt
void flow_stmt() #void: {}
{
    <BREAK> {addToPeek("break",true);} #break_stmt(0)
|   <CONTINUE>  {addToPeek("continue",true);} #continue_stmt(0)
|   return_stmt()
|   yield_stmt()
|   raise_stmt()
}

//return_stmt: 'return' [testlist]
void return_stmt(): {}
{ begin_return_stmt() [SmartTestList()] }

void begin_return_stmt(): {}
{ <RETURN> {this.addToPeek("return ",false);}
}


//yield_stmt: 'yield' [testlist]
void yield_stmt(): {}
{ <YIELD> SmartTestList() {this.addToPeek("yield ",false, Yield.class);}}

//raise_stmt: 'raise' [test [',' test [',' test]]]
void raise_stmt(): {}
{ <RAISE> {this.addSpecialToken("raise ", STRATEGY_BEFORE_NEXT);} [test() [{this.addSpecialToken(",");} <COMMA> test() [{this.addSpecialToken(",");} <COMMA> test()]]] }

//import_stmt: 'import' dotted_name (',' dotted_name)* | 'from' dotted_name 'import' ('*' | NAME (',' NAME)*)
void import_stmt() #void: {Import imp;}
{  <IMPORT> imp = Import() {imp.addSpecial("import ",false);} 
  |<FROM> {this.addSpecialToken("from ",STRATEGY_BEFORE_NEXT);} ImportFrom() 
}


Import Import(): {}
{ dotted_as_name() ({this.addSpecialToken(",");} <COMMA> dotted_as_name())* 
  {return (Import)jjtree.peekNode();}
}

//TODO: allways allowed (treat different versions in other places, to see if this is correct or not)
void ImportFrom(): { String mod; String name;int state=0; }
{
    mod=dotted_name() <IMPORT> {this.addSpecialToken(" import ");}
    (
        //from xxx import *
        <MULTIPLY> {this.addSpecialToken("*",STRATEGY_ADD_AFTER_PREV);}//from xx import *
        
        //from xxx import a,b,c
        | (name=import_as_name() ({this.addSpecialToken(",");} <COMMA> import_as_name())*) 
        
        //from xxx import (a,b,c)
        | <LPAREN>  {this.addSpecialToken("(",STRATEGY_BEFORE_NEXT);}   
          name=import_as_name() 
          (
           ({
             if(state!=0){
                 throw new ParseException("Invalid syntax: 2 commas cannot be grouped.", getToken(1));
             }
             state=1; 
             this.addSpecialToken(",");
             } 
             <COMMA> ( {state=0;} import_as_name())? )* 
           <RPAREN>  {this.findTokenAndAdd(")");} 
          )
    )
}

//dotted_as_name: dotted_name [NAME NAME]
void dotted_as_name(): {}
{ dotted_name() [<AS> {this.addSpecialToken(" as ");} Name()] }

//dotted_name: NAME ('.' NAME)*
String dotted_name(): { Token t; StringBuffer sb = new StringBuffer(); }
{ t=AnyName() { sb.append(t.image); }
    (<DOT> t=AnyName() { sb.append("." + t.image); } )*
        { return sb.toString(); }
}

//import_as_name: NAME [NAME NAME]
String import_as_name(): { Token t; }
{ t=AnyName() [<AS> {this.addSpecialToken(" as ");} Name()] { return t.image; } }

//global_stmt: 'global' NAME (',' NAME)*
void global_stmt(): {}
{ <GLOBAL> {this.addSpecialToken("global ", STRATEGY_BEFORE_NEXT);} Name() ({this.addSpecialToken(",");} <COMMA> Name())* }

//exec_stmt: 'exec' expr ['in' test [',' test]]
void exec_stmt(): {}
{ <EXEC>{this.addSpecialToken("exec ", STRATEGY_BEFORE_NEXT);} expr() [<IN>{this.addSpecialToken(" in ");} test() [{this.addSpecialToken(",");} <COMMA> test()]] }

//assert_stmt: 'assert' test [',' test]
void assert_stmt(): {}
{ <ASSERT> test() [{this.addSpecialToken(",");} <COMMA> test()] }

//compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef
void compound_stmt() #void : { token_source.compound = true; }
{if_stmt() | while_stmt() | for_stmt() | try_stmt()  | funcdef() | classdef()}

//if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
void if_stmt(): {}
{
    begin_if_stmt() test() <COLON> {this.addSpecialToken(":");} suite()
         (begin_elif_stmt() test() <COLON> {this.addSpecialToken(":");} suite())* 
             [ <ELSE> <COLON> {this.findTokenAndAdd("else","else:",true);} suite()]
}

void begin_if_stmt(): {Object spStr;}
{ {spStr = createSpecialStr("if","if ", false);} <IF> {this.addToPeek(spStr,false);} 
}

void begin_elif_stmt(): {}
{ <ELIF> {this.addToPeek("elif",false);}
}


//while_stmt: 'while' test ':' suite ['else' ':' suite]
void while_stmt(): {}
{ begin_while_stmt() test() <COLON> {this.addSpecialToken(":");} suite() 
  [ begin_else_stmt()  suite()] }

void begin_while_stmt(): {}
{ {this.addSpecialToken("while ",STRATEGY_BEFORE_NEXT);} <WHILE> 
}
void begin_else_stmt(): {}
{ <ELSE> {this.addSpecialToken("else",STRATEGY_BEFORE_NEXT);} {this.addSpecialToken(":",STRATEGY_BEFORE_NEXT);} <COLON>  
}

//for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
void for_stmt(): {}
{   begin_for_stmt() exprlist() <IN> {this.addSpecialToken(" in ");} SmartTestList() <COLON> {this.addSpecialToken(":");} suite()
    [begin_for_else_stmt() suite()]
    
} 

void begin_for_stmt(): {}
{ <FOR> {this.addToPeek("for ",false);} 
}

void begin_for_else_stmt(): {}
{ <ELSE> {this.addSpecialToken("else",STRATEGY_BEFORE_NEXT);} {this.addSpecialToken(":",STRATEGY_BEFORE_NEXT);} <COLON>  
}
//try_stmt: ('try' ':' suite (except_clause ':' suite)+ #diagram:break
//           ['else' ':' suite] | 'try' ':' suite 'finally' ':' suite)
void try_stmt() #void: {SimpleNode tryNode;}
{ 
    begin_try_stmt() {tryNode = (SimpleNode)jjtree.peekNode();}  suite() (
    ((except_clause(tryNode))+ 
    
    [begin_try_else_stmt()  suite()])
        #try_stmt(jjtree.nodeArity()+1)
        
    | begin_finally_stmt() suite()
        #tryfinally_stmt(jjtree.nodeArity()+1))
}

//this is the 'try' ':'  it is needed because we need that scope closing for getting the specials.
void begin_try_stmt(): {}
{ <TRY> {this.addSpecialToken("try", STRATEGY_BEFORE_NEXT);} {this.addSpecialToken(":", STRATEGY_BEFORE_NEXT);} <COLON> 
}
void begin_try_else_stmt(): {}
{ <ELSE> {this.addSpecialToken("else", STRATEGY_BEFORE_NEXT);}{this.addSpecialToken(":", STRATEGY_BEFORE_NEXT);}<COLON>
}

void begin_finally_stmt(): {}
{ <FINALLY> {this.addSpecialToken("finally", STRATEGY_BEFORE_NEXT);} {this.addSpecialToken(":", STRATEGY_BEFORE_NEXT);} <COLON> 
}

//except_clause: 'except' [test [',' test]]
void except_clause(SimpleNode tryNode): {}
{ begin_except_clause() {this.addToPeek("except",false);} [test() [{this.addSpecialToken(",");} <COMMA> test()]] <COLON> { this.addSpecialToken(":");} suite() }

void begin_except_clause(): {}
{ <EXCEPT> }


//suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
void suite(): {}
{ simple_stmt() |  <NEWLINE>
                   { token_source.expect_indent = true; } <INDENT> { token_source.expect_indent = false; } (stmt())+ <DEDENT> }


//test: and_test ('or' and_test)* | lambdef
void test() #or_boolean(>1): {}
{ lambdef() | and_test() (<OR_BOOL> and_test())* }

//and_test: not_test ('and' not_test)*
void and_test() #and_boolean(>1): {}
{ not_test() (<AND_BOOL> not_test())* }

//not_test: 'not' not_test | comparison
void not_test() #void: {}
{ <NOT_BOOL> not_test() #not_1op(1) | comparison() }

//comparison: expr (comp_op expr)*
void comparison() #void: {}
{ (expr() (comp_op() expr())*) #comparision(>1) }


//comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
void comp_op() #void: {}
{
    <LESS> #less_cmp(0)
|   <GREATER> #greater_cmp(0)
|   <EQEQUAL> #equal_cmp(0)
|   <EQGREATER> #greater_equal_cmp(0)
|   <EQLESS> #less_equal_cmp(0)
|   <LESSGREATER> #notequal_cmp(0)
|   <NOTEQUAL> #notequal_cmp(0)
|   <IN> #in_cmp(0)
|   <NOT_BOOL> <IN> #not_in_cmp(0)
|   LOOKAHEAD(2) <IS> <NOT_BOOL> #is_not_cmp(0)
|   <IS> #is_cmp(0)
}

//expr: xor_expr ('|' xor_expr)*
void expr() #void : {}
{ xor_expr() (<OR> xor_expr() #or_2op(2))* }

//xor_expr: and_expr ('^' and_expr)*
void xor_expr() #void : {}
{ and_expr() (<XOR> and_expr() #xor_2op(2))* }

//and_expr: shift_expr ('&' shift_expr)*
void and_expr() #void : {}
{ shift_expr() (<AND> shift_expr() #and_2op(2))* }

//shift_expr: arith_expr (('<<'|'>>') arith_expr)*
void shift_expr() #void : {}
{
    arith_expr() (<LSHIFT> arith_expr() #lshift_2op(2)
|   <RSHIFT> arith_expr() #rshift_2op(2) )*
}

//arith_expr: term (('+'|'-') term)*
void arith_expr() #void : {}
{
    term() (<PLUS> term() #add_2op(2)
|   <MINUS> term() #sub_2op(2) )*
}

//term: factor (('*'|'/'|'%') factor)*
void term() #void : {}
{
    factor()  ( <MULTIPLY> factor() #mul_2op(2)
|   <DIVIDE> factor() #div_2op(2)
|   <FLOORDIVIDE> factor() #floordiv_2op(2)
|   <MODULO> factor() #mod_2op(2) )*
}

//factor: ('+'|'-'|'~') factor | power
void factor() #void: {}
{
    <PLUS> factor() #pos_1op(1)
|   <MINUS> factor() #neg_1op(1)
|   <NOT> factor() #invert_1op(1)
|   power()
} /*Modified, no recursion*/

//power: atom trailer* ('**' factor)*
void power() #void: {}
{ atomtrailer() (LOOKAHEAD(2) <POWER> factor() #pow_2op(2))* }

//trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
void atomtrailer() #void: {Object spStr;Object spStr2;}
{
atom() 
(
    LOOKAHEAD(2) (  
    {spStr  = createSpecialStr("(", false);} <LPAREN>  
    {spStr2 = createSpecialStr(")", false);} <RPAREN> 
    )#Call_Op(1) {addToPeekCallFunc(spStr, true); addToPeek(spStr2, true);}

|   LOOKAHEAD(2) (  
    {spStr  = createSpecialStr("(", false);} <LPAREN>  
    insidetuporcall() 
    {spStr2 = createSpecialStr(")", false);} <RPAREN> 
    ) #Call_Op(jjtree.nodeArity()+1) {addToPeekCallFunc(spStr, true); addToPeek(spStr2, true);}


|   {spStr = createSpecialStr("[", false);} <LBRACKET> 
    subscriptlist()
    {spStr2 = createSpecialStr("]", false);} <RBRACKET>  
    #Index_Op(2) {addToPeek(spStr, false); addToPeek(spStr2, true);}

|   <DOT> AnyName() #Dot_Op(2) 
)*
}


//atom: '(' [testlist] ')' | '[' [testlist] ']' | '{' [dictmaker] '}' | '`' testlist '`' | NAME | NUMBER | STRING+
void atom() #void: {Object spStr;Object spStr2;}
{
    LOOKAHEAD(2) (  
      {spStr  = createSpecialStr("(", false);} <LPAREN>  
      {spStr2 = createSpecialStr(")", false);} <RPAREN> 
    ) #tuple {addToPeek(spStr, false); addToPeek(spStr2, true);}

|   LOOKAHEAD(2) (  
      {spStr  = createSpecialStr("(", false);} <LPAREN>  
      insidetuporcall() 
      {spStr2 = createSpecialStr(")", false);} <RPAREN> 
    ) #tuple {addToPeek(spStr, false); addToPeek(spStr2, true);}


|   ( <LPAREN>  {this.addSpecialToken("(",STRATEGY_BEFORE_NEXT);}   [SmartTestList()] <RPAREN>  {this.findTokenAndAdd(")");}  )

|   ( {spStr = createSpecialStr("[", false);} <LBRACKET> 
      [listmaker()] 
      {spStr2 = createSpecialStr("]", false);} <RBRACKET>  
    ) #list {addToPeek(spStr, false); addToPeek(spStr2, true);}
      
      
|   ( {spStr  = createSpecialStr("{", false);}<LBRACE> 
      [dictmaker()] 
      {spStr2  = createSpecialStr("}", false);} <RBRACE> 
    ) #dictionary {addToPeek(spStr, false); addToPeek(spStr2, true);}
    
|   "`" SmartTestList() "`" #str_1op(1)
|   Name() 
|   Number()
|   String() (String() #strjoin(2))*
}

//we can be inside a tuple or a call, and we may have list comprehension in it. (fabioz)
void insidetuporcall() #void: {}
{
    arglist() (list_for())*
}

//lambdef: 'lambda' [varargslist] ':' test
//we add the colon to the args if there is some argument... otherwise, we add it to the first token that appears on the test
void lambdef():{boolean hasArgs=false;}
{ <LAMBDA> [varargslist(){hasArgs=true;}] <COLON> {if(hasArgs)this.addSpecialToken(":");else this.addSpecialToken(":",STRATEGY_BEFORE_NEXT);} test() }

//subscriptlist: subscript (',' subscript)* [',']
void subscriptlist() #void: {}
{ (subscript() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> subscript())* [Comma()]) #subscriptlist(>1) }

//subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
void subscript() #void: {}
{
    <DOT> <DOT> <DOT> #Ellipses
|   (test() (slice())?) #Slice
|   slice() #Slice(>0)
}

//sliceop: ':' [test]
void slice() #void: {}
{ Colon() [test()] (Colon() [test()])? }

void Colon(): {} {{this.addSpecialToken(createSpecialStr(":", false), STRATEGY_BEFORE_NEXT);} <COLON> }
void Comma(): {} {{this.addSpecialToken(",");} <COMMA>}

//exprlist: expr (',' expr)* [',']
void exprlist() #void: {}
{ (expr() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> expr())* [Comma()]) #tuple(>1) }

//testlist: test (',' test)* [',']
void SmartTestList() #void: {}
{ (test() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> test())* [Comma()]) #tuple(>1) }

//testlist: test (',' test)* [',']
void testlist() #void: {}
{ test() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> test())* [{this.addSpecialToken(",");} <COMMA>]}

//dictmaker: test ':' test (',' test ':' test)* [',']
void dictmaker() #void: {}
{test() <COLON> {this.addSpecialToken(":");} test() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> test() <COLON> {this.addSpecialToken(":");} test())* [{this.addSpecialToken(",");} <COMMA>]}

//listmaker: test ( list_for | (',' test)* [','] )
void listmaker() #void: {}
{ test() ( (list_for())+ | (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> test())* [Comma()] #tuple(>1)) }

void complistmaker() #void: {}
{ test() list_for()  
}

//list_iter: [list_for | list_if]
//void list_iter() #void: {}
//{ [ (list_for() | list_if()) ] }

//list_for: 'for' exprlist 'in' testlist list_iter
void list_for(): {}
{ <FOR> {this.addSpecialToken(" for ");} exprlist() <IN> {this.addSpecialToken(" in ");} SmartTestList() (<IF>  {this.addSpecialToken(" if ");} test())* }



//classdef: 'class' NAME ['(' testlist ')'] ':' suite
void classdef(): {}
{<CLASS> Name() [<LPAREN>  {this.addSpecialToken("(",STRATEGY_BEFORE_NEXT);}   testlist() <RPAREN>  {this.findTokenAndAdd(")");} ] <COLON> {this.addSpecialToken(":");} suite()}

//arglist: (argument ',')*
//              (argument [',']| '*' test [',' '**' test] | '**' test)
void arglist() #void: {}
{
    normalargs() [{this.addSpecialToken(",");} <COMMA>
    [LOOKAHEAD(2) ExtraArgValueList()
    [ {this.addSpecialToken(",");} <COMMA> ExtraKeywordValueList() ] | ExtraKeywordValueList()]]
|   [LOOKAHEAD(2) ExtraArgValueList()
    [ {this.addSpecialToken(",");} <COMMA> ExtraKeywordValueList() ] | ExtraKeywordValueList()]
}

void normalargs() #void: {}
{ argument() (LOOKAHEAD(2) {this.addSpecialToken(",");} <COMMA> argument())* }

void ExtraArgValueList(): {}
{ {this.addSpecialToken(createSpecialStr("*", false));} <MULTIPLY> test() }

void ExtraKeywordValueList(): {}
{ ({this.addSpecialToken(createSpecialStr("**", false));} <POWER>
  |{this.addSpecialToken(createSpecialStr("**", false));} <MULTIPLY> <MULTIPLY>)
  test() }


//argument: [test '='] test     # Really [keyword '='] test
void argument() #void: {}
{ ([LOOKAHEAD(2) AnyName() <EQUAL>{this.addSpecialToken("=");}] test()) #Keyword(>1) }


void Number() #Num :
{
    Token t;
}
{
    (
        t=<HEXNUMBER> {
            String s = t.image.substring(2, t.image.length());
            jjtThis.setImage(makeInt(s, 16, t.image));
        } {}
    )
|   (
        t=<OCTNUMBER> { jjtThis.setImage(makeInt(t.image, 8, t.image)); } {}
    )
|   (
        t=<DECNUMBER> { jjtThis.setImage(makeInt(t.image, 10, t.image)); } {}
    )
|   (
        t=<FLOAT> { jjtThis.setImage(makeFloat(t.image)); } {}
    )
|   (
        t=<COMPLEX> { jjtThis.setImage(makeComplex(t.image)); } {}
    )
}

void Complex(): {}
{ <FLOAT>   }

void Name() #Name:
{
    Token t;
}
{
    t = <NAME> { jjtThis.setImage(t.image); } {}
|   t = <AS> { jjtThis.setImage(t.image); } {}
}

void String() #void :
{
    Token t;
}
{
    ( t=<SINGLE_STRING> { jjtThis.setImage(makeString(t.image, 1)); } {} )#String
|   ( t=<SINGLE_STRING2> { jjtThis.setImage(makeString(t.image, 1)); } {} )#String
|   ( t=<TRIPLE_STRING> { jjtThis.setImage(makeString(t.image, 3)); } {} )#String
|   ( t=<TRIPLE_STRING2> { jjtThis.setImage(makeString(t.image, 3)); } {} )#String
|   ( t=<SINGLE_USTRING> { jjtThis.setImage(makeString(t.image, 1)); } {} )#Unicode
|   ( t=<SINGLE_USTRING2> { jjtThis.setImage(makeString(t.image, 1)); } {} )#Unicode
|   ( t=<TRIPLE_USTRING> { jjtThis.setImage(makeString(t.image, 3)); } {} )#Unicode
|   ( t=<TRIPLE_USTRING2> { jjtThis.setImage(makeString(t.image, 3)); } {} )#Unicode
}

Token AnyName() #void:
{
    Token t;
}
{
    ( t= <NAME> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <OR_BOOL> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <AND_BOOL> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <NOT_BOOL> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <IS> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <IN> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <LAMBDA> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <IF> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <ELSE> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <ELIF> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <WHILE> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <FOR> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <TRY> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <EXCEPT> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <DEF> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <CLASS> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <FINALLY> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <PRINT> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <PASS> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <BREAK> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <CONTINUE> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <RETURN> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <YIELD> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <IMPORT> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <FROM> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <DEL> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <RAISE> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <GLOBAL> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <EXEC> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <ASSERT> { jjtThis.setImage(t.image); return t; } {} )#Name
|   ( t = <AS> { jjtThis.setImage(t.image); return t; } {} )#Name
}
